
â— â©  â–¶

â© useState kullanÄ±mÄ± => iÃ§erisinde bir bilgi veya bir durum saklayacaksak ve bu bilgiyi deÄŸiÅŸtireceksek kullanÄ±rÄ±z.

KULLANIMI:
 1. React'ten {useState} import edilecek.
    â–¶ import React, {useState} from 'react';

 2.  kullanÄ±cÄ± her bir harfe bastÄ±ÄŸÄ±nda bu deÄŸer saklanacak. bunun iÃ§in bir deÄŸiÅŸken, bu deÄŸiÅŸkeni deÄŸiÅŸtirecek bir 
 fonk ve 
    ilk deÄŸer tanÄ±mlamasÄ± yapacaÄŸÄ±z.
    â–¶ const [text, setText] = useState("");

3. "text" deÄŸiÅŸkenine deÄŸer gÃ¶nderebilmek iÃ§in bir "metod" kullanÄ±rÄ±z. 'onChangeText'
    â–¶ <TextInput
        onChangeText={value=> setText(value)}
        â© 

4. girilen value'yu TextInput'tan alÄ±yoruz.
    I. girilen deÄŸer "main"e Ã§ekebilmek iÃ§in 'onTodoEnter' isminde tetiklenen bir metod belirliyioruz. 
    BÃ¶ylece mainden tetiklemiÅŸ oluyoruz.;
      â–¶  <TodoInput 
                  onTodoEnter={}

5. girilen ve "text" ile saklanan value yu "onPress" ile "main" deki "todo_Input" a gÃ¶nderebiliyoruz.
    â–¶ <TouchableOpacity 
                onPress={()=> props.onTodoEnter(text)}

6. "main" e gelen value yu Ã§ekebileceÄŸimiz metodun iÃ§ini doldurmanÄ±n zamanÄ± geldi artÄ±k. alÄ±yoruz ve 'alert' 
ekrana bastÄ±rÄ±yoruz.
    â–¶ <TodoInput 
                  onTodoEnter={todoText=>alert(todoText)}

                    â— buradaki 'todoText' parametresi "TodoInput" dan gÃ¶nderirken 'text' parametresi olarak 
                    gÃ¶nderildi
                    fakat 'main' de ismini deÄŸiÅŸtirerek aldÄ±k.

7. Ã¶zet ;
    a. girilen herbir harfi saklayacak useState -> deÄŸiÅŸken -> deÄŸiÅŸkeni kullanan fonk. tanÄ±mlÄ±yoruz
    b. kullanÄ±cÄ±nÄ±n her bir harfe bastÄ±ÄŸÄ±nda bu deÄŸeri alacak metodu "TextInput -> onChangeText -> setText" fonk ile alÄ±yoruz
    c. sonra girilecekle bitince kullanÄ±cÄ± bir butona basÄ±yor. bÃ¶ylece alÄ±nan deÄŸer "main" sayfamÄ±za gÃ¶ndermek iÃ§in
       "onPress" ve "props" kullanÄ±yoruz. bunu da "onPress -> props.fonksiyon()" ile yapÄ±yoruz
    d. artÄ±k verilerimiz "main" sayfasÄ±nda props.fonksiyon ile geldi. burada bu verileri nasÄ±l kullancaÄŸÄ±mÄ±za karar 
        veriyoruz. oluÅŸturduÄŸumuz component'Ä±n iÃ§ine ne yapacaksak onu yazÄ±yoruz.
        fonksiyon = {deÄŸiÅŸken => alert(deÄŸiÅŸken)}

**************************************************

ÅŸimdi yapacaÄŸÄ±mÄ±z ÅŸey girilen verilerin "main" kÄ±smÄ±nda bir array iÃ§erisinde saklamak.

1. array gÃ¶stermek iÃ§in "Flat list" component kullanacaÄŸÄ±z. Flat list scrollview'den kalÄ±tÄ±lmÄ±ÅŸtÄ±r.

2. yukarÄ±dan Ã§agrÄ±sÄ±nÄ± yapÄ±yoruz;
    â–¶ import {SafeAreaView,  StyleSheet,  ScrollView,  View,  Text, FlatList} from 'react-native';

3. Flat bizden 2 tane property ister "data" ve "renderItem"

4. "data" zaten bizim girdiÄŸimiz verilerden oluÅŸan ve "array" tipindedir.

5. "renderItem" ise bir fonksiyonu kullanrak oluÅŸturulan data array inden verileri renderlemeye yarar.

6. FlatList kullanÄ±ldÄ±ÄŸÄ±nda bulunduÄŸu ortamÄ± (flex'i) tamamen kaplar. 

7. kullanÄ±cÄ± veri girdiÄŸinde array'e veri aktarmaya baÅŸlÄ±yoruz.......

8. todo larÄ± saklamak iÃ§in bir useState oluÅŸturuyoruz.
    â–¶ import React, {useState} from 'react';
    â–¶ const [list, setList] = useState([]);

9. artÄ±k FlatList imizin data kÄ±smÄ±nÄ± gÃ¶ndereceÄŸimiz boÅŸ bir array oluÅŸturduk
   â–¶  <FlatList 
                  data={list}

10. kullanÄ±cÄ± "add" butonuna bastÄ±ÄŸÄ±nda girdiÄŸi value yu ekranda gÃ¶rmek istiyoruz.
    (Ã¶nceden alert ile ekran yazdÄ±rdÄ±k) aynÄ± yere yukarÄ±da oluÅŸturduÄŸumuz yeni fonksiyonu yazacaÄŸÄ±z.
    â–¶ function addTodo (text) {
      console.log(text);
    â–¶ <TodoInput 
                  onTodoEnter={todoText=>addTodo(todoText)} 

11.  â—â—â— eger keyboard input'un Ã¶nune geÃ§iyorsa (â—genellikle IOS ta olur);
    â–¶ import {SafeAreaView, ......, KeyboardAvoidingView} from 'react-native';
        sonra en dÄ±ÅŸtaki View'Ä± deÄŸiÅŸtiriyoruz.
        â–¶ return (
             <>
                <SafeAreaView style={main.container} behavior="padding">  â—** behavior="padding"=> keyboard ile input arasÄ±na padding vermemizi saÄŸlÄ±yor.
                    <KeyboardAvoidingView style={main.container}>
                ....
                    </KeyboardAvoidingView>
            
12. yukarÄ±da console' a yazdÄ±rdÄ±ÄŸÄ±mÄ±z text'i oluÅŸturulan fonksiyon ile yeni attributlar kazandÄ±rÄ±rarak yeni bir object oluÅŸturduk.
    â–¶ function addTodo (text) {
        const element = {
            id: list.length,
            todo: text,
            isDone: false,
                }
        }

13. artÄ±k oluÅŸturulan her object'i eski girilenleri koruyarak yeni bir listeye ekleyeceÄŸiz. bunun iÃ§in ne yapacaÄŸÄ±z.;
    ***spread operatoru yardÄ±mÄ±mÄ±za koÅŸuyor***

14. daha Ã¶nce useState ile oluÅŸturduÄŸumuz 'list' e gelen yeni attributlar(valuelar) Ä± yeni array'a ekleyerek devam ediyoruz.
    â–¶ function addTodo (text) {
      const element = {
        id: list.length,
        todo: text,
        isDone: false,
      }
      const newArray = [...list]
      newArray.push(element)

      // console.log(newArray);
      setList(newArray);
      }
        â—â—â— neden useState iÃ§erisindeki list'i direk push yapmadÄ±k'ta yeniden array (newArray) oluÅŸturduk???
        â© ***useState ile oluÅŸturduÄŸumuz liste "read-only"dir ve manÃ¼pÃ¼le edilemez......
        examp:
            const list=[1,2,3,4] 
                bu listeye yeni bir eleman eklemek iÃ§in;
            const new_list = [...list,5]
            console.log(new_list) =>  "[1,2,3,4,5]"
15. ÅŸimdi kodumuzu biraz sadeleÅŸtirelim. yukarÄ±daki 'push'u kullanmadan 'spread' operatoru ile ekleme yapalÄ±m
        â–¶ const newArray = [...list]
           newArray.push(element)
           setList(newArray);
    yerine
        â–¶ const newArray = [...list, element]
           setList(newArray);
    yazabiliriz....
    element'i listenin baÅŸÄ±na eklemek iÃ§in;
        â–¶ const newArray = [element, ...list]
          setList(newArray);

16. ArtÄ±k oluÅŸturacaÄŸÄ±mÄ±z costom component ile bu listeyi ekranda gÃ¶relim.

17. Components klasÃ¶rÃ¼ne yeni bir card component'u ekliyoruz.(TodoCard.js)

18. birÃ§ok component'i export etmektense yeni bir 'index.js' component'i ile iÅŸimizi kolaylaÅŸtÄ±rÄ±yoruz.
    haydi index.js oluÅŸturalÄ±m ve diÄŸer componentleri buaradan export edelim.

19.  index.js iÃ§ini dolduruyoruz;
    â–¶ export * from './TodoInput';
       export * from './TodoCard';

20. artÄ±k TodoCard componentine gelen verileri ekrana yazdÄ±racaÄŸÄ±z. bunu direkt 'main-> renderItem' iÃ§erisine yazabiliriz.
    fakat bÃ¶yle yapmÄ±yoruz Ã§Ã¼nkÃ¼ performansÄ±mÄ±zÄ± etkiliyor.
    
21. bu yÃ¼zden 'main'e bir fonksiyon (tek satÄ±rlÄ±k olacaÄŸÄ± iÃ§in 'return' yazmÄ±yoruz) ile render'e fonksiyonu gÃ¶ndereceÄŸiz
    â–¶ import {TodoInput, TodoCard} from './components';
    
    â–¶ const renderTodo = ({item}) => <TodoCard data={item}/>   â—todoCard Ä±n data isimli prop una item'Ä± gÃ¶nderdik.
    
    â–¶ <FlatList 
                  data={list}
                  renderItem={renderTodo}     

22. ÅŸimdi 'TodoCard' component iÃ§erisinde "renderItem->renderTodo->TodoCard" ile Ã§ektiÄŸimiz verileri gÃ¶rebileceÄŸiz.
    renderTodo iÃ§erisindeki herbir "data = {item}" aÅŸaÄŸÄ±daki "element"e tekabÃ¼l ediyor.
            function addTodo (text) {
            const element = {
                id: list.length,
                todo: text,
                isDone: false,
            }
    o zaman 'TodoCard' iÃ§erisindeki codumuz;
    â–¶   import React from 'react';
        import {Text, View, TouchableOpacity} from 'react-native';

        const TodoCard = (props) => {
        return (
            <View>
                <Text>{props.data.todo}</Text>
            </View>
        )}

        export {TodoCard};

23. ArtÄ±k ekranda gÃ¶rebiliyoruz...

24. yukarÄ±da girdiÄŸimiz herbir todo yu sayan bir rakam girmiÅŸtik. buraya bir counter componenti ile girilenleri 
    saydÄ±rabilriz. fakat uygulamaya extra yÃ¼k bindirmemek iÃ§in bunu listenin uzunluÄŸu ile hallediyoruz.
     â–¶ <Text style={main.todoCount}>{list.length}</Text>   

25. todo lara style verebiliriz artÄ±k. "styles" componentine geliyoruz.
    â–¶ const todo_card = StyleSheet.create ({
        container:{
        backgroundColor:'#90cc00',
        },
        })
    export etmeyi de unutmayalÄ±m.
    â–¶ export {main, todo_Input, todo_card};

26. sonra 'TodoCard' componentine geliyoruz ve style componentine baÄŸlÄ±yoruz.
    â–¶ import {todo_card} from '../styles'

    â–¶ <View style={todo_card.container}>

27. text'e de style verebiliriz artÄ±k..

28. unuttugumuz bir nokta. "main -> FlatList" e 'keyExtractor' eklemek. Hemen ekleyeceÄŸiz. 'keyExtractor' bizden 2 adet
    parametre alÄ±r. bunlar "item ve index". burada ister "item" ister "index" herhangi birisini kullanabilirsiniz.
    ama bunlardan en saÄŸlÄ±klÄ±sÄ± "index" kullanmaktÄ±r.
    â–¶ <FlatList
                  keyExtractor = {(item, index)=> index.toString()}  â— "index" string formatÄ± kullandÄ±ÄŸÄ± iÃ§in 'toString' kullandÄ±k

29. ÅŸimdi liste boÅŸken ekrana birÅŸey yazdÄ±rmak istiyoruz. !!Placeholder gibi. 
    FlatList in hazÄ±r bir property si var; "ListEmptyComponent". fakat bu bizden boÅŸ bir component ister.
    â–¶<FlatList
            ListEmptyComponent={()=> <Text style={main.emptyComponent}>Nothing to do yet!!</Text>}

30. style component'Ä±ndan ListEmptyComponent'a style verebilirsiniz.           

31. todo ekledikten sonra, eklediÄŸimiz todo_card'Ä±n Ã¼zerine tÄ±klayÄ±nca bir eylem yapmasÄ±nÄ± istiyoruz. mesala Ã¼zerini Ã§izsin.
    ve tamamlanmÄ±ÅŸ gÃ¶rÃ¼nsÃ¼n.

32. bÄ±nun iÃ§in TodoCard component'a gidiyoruz ve 'TouchableOpacity' ile buton tasarÄ±mÄ± yapacaÄŸÄ±z.

33. daha Ã¶nce View ile yaptÄ±ÄŸÄ±mÄ±z todo_card'larÄ± 'TouchableOpacity'e Ã§eviriyoruz.
       â–¶const TodoCard = (props) => {
            return (
                <TouchableOpacity style={todo_card.container}>
                    <Text style={todo_card.text}>ğŸ™‚{props.data.todo}</Text>
                </TouchableOpacity>
            )
        }

34. bunun iÃ§in 'main-> element' iÃ§erisindeki "isDone: false", kÄ±smÄ±nÄ± deÄŸiÅŸtireceÄŸiz.

35. ilk todo_card iÃ§erisindeki TouchableOpacity'e onPress ile bir fonksiyon ekliyoruz;
    â–¶<TouchableOpacity 
            style={todo_card.container}
            onPress={()=> props.onDone()}

36. "main"e geliyoruz. burada iki ekleme yapacaÄŸÄ±z;
    1. "renderTodo"ya (todo'muzu ekrana basan fonk.) "props.onDone" ile tetiklenen bilgiyi ileteceÄŸiz
        â–¶ const renderTodo = ({item}) => {
                return(
                    <TodoCard 
                        data={item}
                        onDone={()=>doneTodo(item.id)}
                    />
                )}
    2. bu bilgiyi kullancak bir fonksiyon yazacaÄŸÄ±z. yani bu veriye sahip oldumuzda ne yapsÄ±n uygulama. ornek olarak
        alert ile ekrana bilgi verebilirsiniz
        â–¶ function doneTodo(todoId) {
            alert("yaptÄ±k")
            }

37. ÅŸimdi hangi todo'ya dokunulursa ona ana listeden eriÅŸip isDone'Ä±nÄ± deÄŸiÅŸtireceÄŸiz.
fonksiyonu manÃ¼pÃ¼le etmeye baÅŸlÄ±yoruz. "function doneTodo(todoId)......"
    * ana listemi kopyaladÄ±m 
        â–¶ const newArray = {...list};
    * todu' nun listedeki index'ini bulacaÄŸÄ±z. tamamlanmÄ±ÅŸ hale getireceÄŸiz yani isDone deÄŸerini deÄŸiÅŸtireceÄŸiz
        â–¶ const todoIndex = newArray.findIndex(item=> item.id == todoId);

        â–¶ newArray[todoIndex].isDone = !newArray[todoIndex].isDone;
           setList(newArray)
    * ÅŸimdi tamamlanmÄ±ÅŸ haline farklÄ± bir style verelim. Ã¼stÃ¼nÃ¼ Ã§izelim.
        bunu koÅŸul ile yapacaÄŸÄ±z. isDone=true ise .... deÄŸilse ......
        style override ile koÅŸul tanÄ±mlamasÄ± yapacaÄŸÄ±z. TodoCard->Text' gidiyoruz...
        â–¶ <Text style={[
                todo_card.text,
                {textDecorationLine: props.data.isDone ? 'line-through' : null}
                ]}
                >ğŸ™‚{props.data.todo}</Text>

38. sÄ±rada; bir todo'yu iÅŸaretledigimiz zaman counter'Ä±n sayÄ±sÄ±nÄ±n azalmasÄ±nÄ± istiyoruz;
    "main->list.length" e gidiyoruz. ve isDone durumlarÄ± "false" olanlarÄ± saydÄ±racagÄ±z
    
39. listeyi filtreleme yapÄ±yoruz.
    â–¶ return (
        .....
        <Text style={main.todoCount}>{list.filter(t => t.isDone === false).length}</Text>

40. todo silmek iÃ§in bir buton veya ÄŸzerine basÄ±lÄ± tuttuÄŸumuzda silmesini istiyoruz.
    "TodoCard" component gidiyoruz. ve onLongPress attr. kullanÄ±yoruz. 
    "onRemove" adÄ±nda bir fonksiyon ile tetikleme yapÄ±yoruz 
    â–¶ return (
        ...
        onLongPress={()=>props.onRemove()}

41. "main"e geliyoruz ve tetiklediÄŸimiz fonksiyonu render iÃ§erisinde yakalÄ±yoruz;
     â–¶ const renderTodo = ({ item }) => {
            return (
                <TodoCard
                    data={item}
                    onDone={() => doneTodo(item.id)}
                    onRemove={() => alert("silinsin mi?")}

42. yakaladÄ±ÄŸÄ±mÄ±z isteÄŸi bir fonksiyon ile harekete geÃ§iriyoruz
    fonksiyon iÃ§erisinde Ã¶nce eski listenin bir kopyasÄ±nÄ± oluÅŸturduk, sonra onu manÃ¼pÃ¼le ettik. nasÄ±l mÄ±?
    Ã¶nce ilgili elemanÄ±n id sini tespit ediyoruz sonra onun idex'i Ã¼zerinden kaldÄ±rÄ±yoruz.
    â–¶ function removeTodo(todoId){
            const newArray = [...list];
            const todoIndex = list.findIndex(t=>t.id==todoId);
            newArray.splice(todoIndex, 1);
            setList(newArray);
       }


