
❗ ⏩  ▶

⏩ useState kullanımı => içerisinde bir bilgi veya bir durum saklayacaksak ve bu bilgiyi değiştireceksek kullanırız.

KULLANIMI:
 1. React'ten {useState} import edilecek.
    ▶ import React, {useState} from 'react';

 2.  kullanıcı her bir harfe bastığında bu değer saklanacak. bunun için bir değişken, bu değişkeni değiştirecek bir 
 fonk ve 
    ilk değer tanımlaması yapacağız.
    ▶ const [text, setText] = useState("");

3. "text" değişkenine değer gönderebilmek için bir "metod" kullanırız. 'onChangeText'
    ▶ <TextInput
        onChangeText={value=> setText(value)}
        ⏩ 

4. girilen value'yu TextInput'tan alıyoruz.
    I. girilen değer "main"e çekebilmek için 'onTodoEnter' isminde tetiklenen bir metod belirliyioruz. 
    Böylece mainden tetiklemiş oluyoruz.;
      ▶  <TodoInput 
                  onTodoEnter={}

5. girilen ve "text" ile saklanan value yu "onPress" ile "main" deki "todo_Input" a gönderebiliyoruz.
    ▶ <TouchableOpacity 
                onPress={()=> props.onTodoEnter(text)}

6. "main" e gelen value yu çekebileceğimiz metodun içini doldurmanın zamanı geldi artık. alıyoruz ve 'alert' 
ekrana bastırıyoruz.
    ▶ <TodoInput 
                  onTodoEnter={todoText=>alert(todoText)}

                    ❗ buradaki 'todoText' parametresi "TodoInput" dan gönderirken 'text' parametresi olarak 
                    gönderildi
                    fakat 'main' de ismini değiştirerek aldık.

7. özet ;
    a. girilen herbir harfi saklayacak useState -> değişken -> değişkeni kullanan fonk. tanımlıyoruz
    b. kullanıcının her bir harfe bastığında bu değeri alacak metodu "TextInput -> onChangeText -> setText" fonk ile alıyoruz
    c. sonra girilecekle bitince kullanıcı bir butona basıyor. böylece alınan değer "main" sayfamıza göndermek için
       "onPress" ve "props" kullanıyoruz. bunu da "onPress -> props.fonksiyon()" ile yapıyoruz
    d. artık verilerimiz "main" sayfasında props.fonksiyon ile geldi. burada bu verileri nasıl kullancağımıza karar 
        veriyoruz. oluşturduğumuz component'ın içine ne yapacaksak onu yazıyoruz.
        fonksiyon = {değişken => alert(değişken)}

**************************************************

şimdi yapacağımız şey girilen verilerin "main" kısmında bir array içerisinde saklamak.

1. array göstermek için "Flat list" component kullanacağız. Flat list scrollview'den kalıtılmıştır.

2. yukarıdan çagrısını yapıyoruz;
    ▶ import {SafeAreaView,  StyleSheet,  ScrollView,  View,  Text, FlatList} from 'react-native';

3. Flat bizden 2 tane property ister "data" ve "renderItem"

4. "data" zaten bizim girdiğimiz verilerden oluşan ve "array" tipindedir.

5. "renderItem" ise bir fonksiyonu kullanrak oluşturulan data array inden verileri renderlemeye yarar.

6. FlatList kullanıldığında bulunduğu ortamı (flex'i) tamamen kaplar. 

7. kullanıcı veri girdiğinde array'e veri aktarmaya başlıyoruz.......

8. todo ları saklamak için bir useState oluşturuyoruz.
    ▶ import React, {useState} from 'react';
    ▶ const [list, setList] = useState([]);

9. artık FlatList imizin data kısmını göndereceğimiz boş bir array oluşturduk
   ▶  <FlatList 
                  data={list}

10. kullanıcı "add" butonuna bastığında girdiği value yu ekranda görmek istiyoruz.
    (önceden alert ile ekran yazdırdık) aynı yere yukarıda oluşturduğumuz yeni fonksiyonu yazacağız.
    ▶ function addTodo (text) {
      console.log(text);
    ▶ <TodoInput 
                  onTodoEnter={todoText=>addTodo(todoText)} 

11.  ❗❗❗ eger keyboard input'un önune geçiyorsa (❗genellikle IOS ta olur);
    ▶ import {SafeAreaView, ......, KeyboardAvoidingView} from 'react-native';
        sonra en dıştaki View'ı değiştiriyoruz.
        ▶ return (
             <>
                <SafeAreaView style={main.container} behavior="padding">  ❗** behavior="padding"=> keyboard ile input arasına padding vermemizi sağlıyor.
                    <KeyboardAvoidingView style={main.container}>
                ....
                    </KeyboardAvoidingView>
            
12. yukarıda console' a yazdırdığımız text'i oluşturulan fonksiyon ile yeni attributlar kazandırırarak yeni bir object oluşturduk.
    ▶ function addTodo (text) {
        const element = {
            id: list.length,
            todo: text,
            isDone: false,
                }
        }

13. artık oluşturulan her object'i eski girilenleri koruyarak yeni bir listeye ekleyeceğiz. bunun için ne yapacağız.;
    ***spread operatoru yardımımıza koşuyor***

14. daha önce useState ile oluşturduğumuz 'list' e gelen yeni attributlar(valuelar) ı yeni array'a ekleyerek devam ediyoruz.
    ▶ function addTodo (text) {
      const element = {
        id: list.length,
        todo: text,
        isDone: false,
      }
      const newArray = [...list]
      newArray.push(element)

      // console.log(newArray);
      setList(newArray);
      }
        ❗❗❗ neden useState içerisindeki list'i direk push yapmadık'ta yeniden array (newArray) oluşturduk???
        ⏩ ***useState ile oluşturduğumuz liste "read-only"dir ve manüpüle edilemez......
        examp:
            const list=[1,2,3,4] 
                bu listeye yeni bir eleman eklemek için;
            const new_list = [...list,5]
            console.log(new_list) =>  "[1,2,3,4,5]"
15. şimdi kodumuzu biraz sadeleştirelim. yukarıdaki 'push'u kullanmadan 'spread' operatoru ile ekleme yapalım
        ▶ const newArray = [...list]
           newArray.push(element)
           setList(newArray);
    yerine
        ▶ const newArray = [...list, element]
           setList(newArray);
    yazabiliriz....
    element'i listenin başına eklemek için;
        ▶ const newArray = [element, ...list]
          setList(newArray);

16. Artık oluşturacağımız costom component ile bu listeyi ekranda görelim.

17. Components klasörüne yeni bir card component'u ekliyoruz.(TodoCard.js)

18. 2 h 44 m kaldık